package modules::local::githubparser;
use strict;
use warnings;

use YAML::Syck;
use HTML::Entities;

use base 'modules::local::karmalog';

=head1 NAME

    modules::local::githubparser

=head1 DESCRIPTION

This module is responsible for parsing ATOM feeds generated by github.com.  It
is also knowledgeable enough about github's URL schemes to be able to recognise
repository URLs, extract the project name/owner/path and generate ATOM feed
URLs.

=head1 METHODS

=head2 process_branch

    $self->process_branch($feed, $targets);

Fetches the ATOM feed for the 
Enumerates the commits in the feed, emitting any events it hasn't seen before.

=cut

sub process_feed {
    my ($self, $feedid, $targets) = @_;

    my ($author, $project, $branchname) = split '/', $feedid, 3;
    my $url = "https://github.com/api/v2/yaml/commits/list/$author/$project/$branchname";
    my $feed = get_yaml($url);

    if(!defined($feed)) {
        ::lprint("could not fetch $feedid feed $url");
        return;
    }
    ::lprint("fetching branch $feedid feed $url");

    my @items = @{$$feed{commits}};
    @items = sort { $$a{committed_date} cmp $$b{committed_date} } @items; # ascending order
    my $newest = $items[-1];
    my $latest = $$newest{committed_date};

    foreach my $item (@items) {
        ::try_item($self, $feedid, $targets, $$item{id}, $item);
    }
    ::mark_feed_started(__PACKAGE__, $feedid);
}

=head2 try_link

    modules::local::githubparser->try_link(
        $url,
        ['network', '#channel'],
        [qw(master ng)]
    );

This is called by autofeed.pm.  Given a github.com URL, try to determine the
project name and canonical path.  Then configure a feed reader for it if one
doesn't already exist.

Currently supports 3 URL formats:

    https://github.com/tene/gil/
    https://wiki.github.com/TiMBuS/fun
    https://bschmalhofer.github.com/hq9plus/

...with or without a suffix of "/" or "/tree/master".  This covers all of the
links on the Languages page at time of writing.

=cut

sub parse_url {
    my ($pkg, $url, $branch) = @_;

    my($author, $project);
    if($url =~ m|https://(?:wiki.)?github.com/([^/]+)/([^/]+)/?|) {
        $author  = $1;
        $project = $2;
    } elsif($url =~ m|https://([^.]+).github.com/([^/]+)/?|) {
        $author  = $1;
        $project = $2;
    } else {
        # whatever it is, we can't handle it.  Log and return.
        main::lprint("github try_link(): I can't handle $url");
        return;
    }

    return "$author/$project/$branch";
}

=head2 output_item

    $self->output_item($item, $branch, $link, $revision);

Takes an XML::Atom::Entry object, extracts the useful bits from it and calls
put() to emit the karma message.

The karma message is typically as follows:

feedname/branch: $revision | username++ | $commonprefix:
feedname/branch: One or more lines of commit log message
feedname/branch: review: https://link/to/github/diff/page

The "/branch" suffix is only emitted if we track more than one branch for this
repository.

=cut

sub format_item {
    my ($self, $feedid, $rev, $item) = @_;

    my ($author, $project, $branch) = split '/', $feedid, 3;

    my $link    = "https://github.com" . $$item{url};

    my $prefix  = 'unknown';
    my $creator = $$item{author}{login} || $$item{author}{name} || 'unknown';
    my $desc    = $$item{message} // '(no commit message)';

    my @lines = split("\n", $desc);
    pop(@lines) if $lines[-1] =~ /^git-svn-id: http/;
    pop(@lines) while scalar(@lines) && $lines[-1] eq '';

    my @files;
    my $commit = get_yaml("https://github.com/api/v2/yaml/commits/show/$author/$project/$rev");
    if(defined($commit)) {
        $commit = $$commit{commit};
        @files = map { $$_{filename} } (@{$$commit{modified}});
        @files = (@files, @{$$commit{added}})   if exists $$commit{added};
        @files = (@files, @{$$commit{removed}}) if exists $$commit{removed};
        $prefix = ::longest_common_prefix(@files);
        if(defined($prefix) && length($prefix)) {
            # cut off the leading slash.
            $prefix =~ s|^/||;
        } else {
            # add a leading slash, just to be different.
            $prefix = '/' unless(defined($prefix) && length($prefix));
        }
        if(scalar @files > 1) {
            $prefix .= " (" . scalar(@files) . " files)";
        }
    }

    $rev = substr($rev, 0, 7);

    if ($branch ne 'master') {
        $project .= "/$branch";
    }

    $self->format_karma_message(
        feed    => $project,
        rev     => $rev,
        user    => $creator,
        log     => \@lines,
        link    => $link,
        prefix  => $prefix
    );
}

=head2 get_yaml

Given a URL, fetches content and tries to parse as a YAML document.  Returns
undef on error.

=cut

sub get_yaml {
    my $url = shift;
    my $response = ::fetch_url($url);
    if (defined $response) {
        my $rv = Load($response);
        return $rv;
    }
    return undef;
}

1;
